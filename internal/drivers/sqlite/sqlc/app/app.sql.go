// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: app.sql

package appDB

import (
	"context"
	"database/sql"
)

const cardExists = `-- name: CardExists :one
SELECT EXISTS (
    SELECT 1
    FROM cards
    WHERE id = ?1 AND finish = ?2 AND language = ?3
)
`

type CardExistsParams struct {
	ID       string `json:"id"`
	Finish   string `json:"finish"`
	Language string `json:"language"`
}

func (q *Queries) CardExists(ctx context.Context, arg CardExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.cardExistsStmt, cardExists, arg.ID, arg.Finish, arg.Language)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const countCardsWithPrice = `-- name: CountCardsWithPrice :one
SELECT
    COUNT(c.id)
FROM
    cards AS c
JOIN
    cards_price AS p
      ON p.card_id = c.id
     AND p.finish  = c.finish
WHERE
    (?1 = '' OR c.set_code = ?1)          
    AND (?2 = '' OR c.name_en LIKE '%' || ?2 || '%')
`

type CountCardsWithPriceParams struct {
	SetCode interface{} `json:"set_code"`
	Name    interface{} `json:"name"`
}

func (q *Queries) CountCardsWithPrice(ctx context.Context, arg CountCardsWithPriceParams) (int64, error) {
	row := q.queryRow(ctx, q.countCardsWithPriceStmt, countCardsWithPrice, arg.SetCode, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilteredCards = `-- name: CountFilteredCards :one
SELECT
    COUNT(c.id)
FROM cards AS c
JOIN cards_price AS p
      ON p.card_id = c.id
     AND p.finish  = c.finish
WHERE
    -- Name filter
    (?1 = '' OR c.name_en LIKE '%' || ?1 || '%')

    -- Language Filter
    AND (
        (?2 = 0 AND ?3 = 0)
        OR (?2 = 1 AND c.language = 'English')
        OR (?3 = 1 AND c.language = 'Spanish')
    )

    -- Color Filter --------------------------------------------------------
    AND (
        -- loose + colourless  ->  accept every card (skip colour filter)
        (?4 = 'loose' AND ?5 = 1)

        OR

        -- normal loose match
        (
            ?4 = 'loose'
            AND (
                   (?6 = 1 AND c.colors LIKE '%B%')
                OR (?7 = 1 AND c.colors LIKE '%G%')
                OR (?8 = 1 AND c.colors LIKE '%R%')
                OR (?9 = 1 AND c.colors LIKE '%U%')
                OR (?10 = 1 AND c.colors LIKE '%W%')
                OR (?5 = 1 AND c.colors = '')
            )
        )

        -- tight match
        OR (
            ?4 = 'tight'
            AND (
                   (?5 = 1 AND c.colors = '')
                OR (?11 <> '' AND c.colors = ?11)
            )
        )
    )

    -- Other simple 1-of filters
    AND (?12   = '' OR c.types      = ?12)
    AND (?13     = -1 OR c.mana_value = ?13)
    AND (?14 = '' OR c.finish     = ?14)
    AND (?15 = 0 OR p.price >= ?15)
    AND (?16 = 0 OR p.price <= ?16)
`

type CountFilteredCardsParams struct {
	CardName     interface{} `json:"cardName"`
	LangEn       interface{} `json:"langEn"`
	LangES       interface{} `json:"langES"`
	MatchType    interface{} `json:"matchType"`
	Colorless    interface{} `json:"colorless"`
	ColorB       interface{} `json:"colorB"`
	ColorG       interface{} `json:"colorG"`
	ColorR       interface{} `json:"colorR"`
	ColorU       interface{} `json:"colorU"`
	ColorW       interface{} `json:"colorW"`
	CardColor    interface{} `json:"cardColor"`
	CardType     interface{} `json:"cardType"`
	CardMv       interface{} `json:"cardMv"`
	CardFinish   interface{} `json:"cardFinish"`
	CardPriceMin interface{} `json:"cardPriceMin"`
	CardPriceMax interface{} `json:"cardPriceMax"`
}

func (q *Queries) CountFilteredCards(ctx context.Context, arg CountFilteredCardsParams) (int64, error) {
	row := q.queryRow(ctx, q.countFilteredCardsStmt, countFilteredCards,
		arg.CardName,
		arg.LangEn,
		arg.LangES,
		arg.MatchType,
		arg.Colorless,
		arg.ColorB,
		arg.ColorG,
		arg.ColorR,
		arg.ColorU,
		arg.ColorW,
		arg.CardColor,
		arg.CardType,
		arg.CardMv,
		arg.CardFinish,
		arg.CardPriceMin,
		arg.CardPriceMax,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCard = `-- name: CreateCard :exec
INSERT INTO cards (
    id,
    name_en,
    name_es,
    sku,
    set_name,
    set_code,
    mana_value,
    colors,
    types,
    rarity,
    number,
    finish,
    has_vendor,
    language,
    visibility,
    image_path,
    image_url,
    stock
) VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6,
    ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14,
    ?15, ?16, ?17, ?18
)
`

type CreateCardParams struct {
	ID         string         `json:"id"`
	NameEn     string         `json:"name_en"`
	NameEs     string         `json:"name_es"`
	Sku        string         `json:"sku"`
	SetName    string         `json:"set_name"`
	SetCode    string         `json:"set_code"`
	ManaValue  int64          `json:"mana_value"`
	Colors     string         `json:"colors"`
	Types      string         `json:"types"`
	Rarity     string         `json:"rarity"`
	Number     string         `json:"number"`
	Finish     string         `json:"finish"`
	HasVendor  bool           `json:"has_vendor"`
	Language   string         `json:"language"`
	Visibility int64          `json:"visibility"`
	ImagePath  sql.NullString `json:"image_path"`
	ImageUrl   string         `json:"image_url"`
	Stock      int64          `json:"stock"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) error {
	_, err := q.exec(ctx, q.createCardStmt, createCard,
		arg.ID,
		arg.NameEn,
		arg.NameEs,
		arg.Sku,
		arg.SetName,
		arg.SetCode,
		arg.ManaValue,
		arg.Colors,
		arg.Types,
		arg.Rarity,
		arg.Number,
		arg.Finish,
		arg.HasVendor,
		arg.Language,
		arg.Visibility,
		arg.ImagePath,
		arg.ImageUrl,
		arg.Stock,
	)
	return err
}

const getCard = `-- name: GetCard :one
SELECT id, name_en, name_es, sku, set_name, set_code, mana_value, colors, types, rarity, number, finish, has_vendor, language, visibility, image_path, image_url, stock, created_at, updated_at
FROM cards
WHERE id = ?1
`

func (q *Queries) GetCard(ctx context.Context, id string) (Card, error) {
	row := q.queryRow(ctx, q.getCardStmt, getCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.NameEn,
		&i.NameEs,
		&i.Sku,
		&i.SetName,
		&i.SetCode,
		&i.ManaValue,
		&i.Colors,
		&i.Types,
		&i.Rarity,
		&i.Number,
		&i.Finish,
		&i.HasVendor,
		&i.Language,
		&i.Visibility,
		&i.ImagePath,
		&i.ImageUrl,
		&i.Stock,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCardHasVendorById = `-- name: GetCardHasVendorById :one
SELECT has_vendor
FROM cards
WHERE id = ?1
`

func (q *Queries) GetCardHasVendorById(ctx context.Context, id string) (bool, error) {
	row := q.queryRow(ctx, q.getCardHasVendorByIdStmt, getCardHasVendorById, id)
	var has_vendor bool
	err := row.Scan(&has_vendor)
	return has_vendor, err
}

const getCardStockById = `-- name: GetCardStockById :one
SELECT stock
FROM cards
WHERE id = ?1 AND language = ?2 AND finish = ?3
`

type GetCardStockByIdParams struct {
	ID       string `json:"id"`
	Language string `json:"language"`
	Finish   string `json:"finish"`
}

func (q *Queries) GetCardStockById(ctx context.Context, arg GetCardStockByIdParams) (int64, error) {
	row := q.queryRow(ctx, q.getCardStockByIdStmt, getCardStockById, arg.ID, arg.Language, arg.Finish)
	var stock int64
	err := row.Scan(&stock)
	return stock, err
}

const getCardsWithPrice = `-- name: GetCardsWithPrice :many
SELECT
    c.id, c.name_en, c.name_es, c.sku, c.set_name, c.set_code, c.mana_value, c.colors, c.types, c.rarity, c.number, c.finish, c.has_vendor, c.language, c.visibility, c.image_path, c.image_url, c.stock, c.created_at, c.updated_at,
    p.price
FROM
    cards AS c
JOIN
    cards_price AS p
      ON p.card_id = c.id
     AND p.finish  = c.finish
WHERE
    (?1 = '' OR c.set_code = ?1)          
    AND (?2 = '' OR c.name_en LIKE '%' || ?2 || '%')
LIMIT  ?4
OFFSET ?3
`

type GetCardsWithPriceParams struct {
	SetCode interface{} `json:"set_code"`
	Name    interface{} `json:"name"`
	Offset  int64       `json:"offset"`
	Limit   int64       `json:"limit"`
}

type GetCardsWithPriceRow struct {
	ID         string         `json:"id"`
	NameEn     string         `json:"name_en"`
	NameEs     string         `json:"name_es"`
	Sku        string         `json:"sku"`
	SetName    string         `json:"set_name"`
	SetCode    string         `json:"set_code"`
	ManaValue  int64          `json:"mana_value"`
	Colors     string         `json:"colors"`
	Types      string         `json:"types"`
	Rarity     string         `json:"rarity"`
	Number     string         `json:"number"`
	Finish     string         `json:"finish"`
	HasVendor  bool           `json:"has_vendor"`
	Language   string         `json:"language"`
	Visibility int64          `json:"visibility"`
	ImagePath  sql.NullString `json:"image_path"`
	ImageUrl   string         `json:"image_url"`
	Stock      int64          `json:"stock"`
	CreatedAt  string         `json:"created_at"`
	UpdatedAt  string         `json:"updated_at"`
	Price      float64        `json:"price"`
}

func (q *Queries) GetCardsWithPrice(ctx context.Context, arg GetCardsWithPriceParams) ([]GetCardsWithPriceRow, error) {
	rows, err := q.query(ctx, q.getCardsWithPriceStmt, getCardsWithPrice,
		arg.SetCode,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCardsWithPriceRow
	for rows.Next() {
		var i GetCardsWithPriceRow
		if err := rows.Scan(
			&i.ID,
			&i.NameEn,
			&i.NameEs,
			&i.Sku,
			&i.SetName,
			&i.SetCode,
			&i.ManaValue,
			&i.Colors,
			&i.Types,
			&i.Rarity,
			&i.Number,
			&i.Finish,
			&i.HasVendor,
			&i.Language,
			&i.Visibility,
			&i.ImagePath,
			&i.ImageUrl,
			&i.Stock,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilteredCards = `-- name: GetFilteredCards :many
SELECT
    c.id,
    c.name_en,
    c.language,
    p.price,
    c.image_url,
    c.finish,
    c.rarity,
    c.mana_value,
    c.colors,
    c.types
FROM cards AS c
JOIN cards_price AS p
      ON p.card_id = c.id
     AND p.finish  = c.finish
WHERE
    -- Name filter
    (?1 = '' OR c.name_en LIKE '%' || ?1 || '%')

    -- Language Filter
    AND (
        (?2 = 0 AND ?3 = 0)
        OR (?2 = 1 AND c.language = 'English')
        OR (?3 = 1 AND c.language = 'Spanish')
    )

    -- Color Filter --------------------------------------------------------
    AND (
        -- loose + colourless  ->  accept every card (skip colour filter)
        (?4 = 'loose' AND ?5 = 1)

        OR

        -- normal loose match
        (
            ?4 = 'loose'
            AND (
                   (?6 = 1 AND c.colors LIKE '%B%')
                OR (?7 = 1 AND c.colors LIKE '%G%')
                OR (?8 = 1 AND c.colors LIKE '%R%')
                OR (?9 = 1 AND c.colors LIKE '%U%')
                OR (?10 = 1 AND c.colors LIKE '%W%')
                OR (?5 = 1 AND c.colors = '')
            )
        )

        -- tight match
        OR (
            ?4 = 'tight'
            AND (
                   (?5 = 1 AND c.colors = '')
                OR (?11 <> '' AND c.colors = ?11)
            )
        )
    )

    -- Other simple 1-of filters
    AND (?12   = '' OR c.types      = ?12)
    AND (?13     = -1 OR c.mana_value = ?13)
    AND (?14 = '' OR c.finish     = ?14)
    AND (?15 = 0 OR p.price >= ?15)
    AND (?16 = 0 OR p.price <= ?16)

LIMIT ?18
OFFSET ?17
`

type GetFilteredCardsParams struct {
	CardName     interface{} `json:"cardName"`
	LangEn       interface{} `json:"langEn"`
	LangES       interface{} `json:"langES"`
	MatchType    interface{} `json:"matchType"`
	Colorless    interface{} `json:"colorless"`
	ColorB       interface{} `json:"colorB"`
	ColorG       interface{} `json:"colorG"`
	ColorR       interface{} `json:"colorR"`
	ColorU       interface{} `json:"colorU"`
	ColorW       interface{} `json:"colorW"`
	CardColor    interface{} `json:"cardColor"`
	CardType     interface{} `json:"cardType"`
	CardMv       interface{} `json:"cardMv"`
	CardFinish   interface{} `json:"cardFinish"`
	CardPriceMin interface{} `json:"cardPriceMin"`
	CardPriceMax interface{} `json:"cardPriceMax"`
	Offset       int64       `json:"offset"`
	Limit        int64       `json:"limit"`
}

type GetFilteredCardsRow struct {
	ID        string  `json:"id"`
	NameEn    string  `json:"name_en"`
	Language  string  `json:"language"`
	Price     float64 `json:"price"`
	ImageUrl  string  `json:"image_url"`
	Finish    string  `json:"finish"`
	Rarity    string  `json:"rarity"`
	ManaValue int64   `json:"mana_value"`
	Colors    string  `json:"colors"`
	Types     string  `json:"types"`
}

func (q *Queries) GetFilteredCards(ctx context.Context, arg GetFilteredCardsParams) ([]GetFilteredCardsRow, error) {
	rows, err := q.query(ctx, q.getFilteredCardsStmt, getFilteredCards,
		arg.CardName,
		arg.LangEn,
		arg.LangES,
		arg.MatchType,
		arg.Colorless,
		arg.ColorB,
		arg.ColorG,
		arg.ColorR,
		arg.ColorU,
		arg.ColorW,
		arg.CardColor,
		arg.CardType,
		arg.CardMv,
		arg.CardFinish,
		arg.CardPriceMin,
		arg.CardPriceMax,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredCardsRow
	for rows.Next() {
		var i GetFilteredCardsRow
		if err := rows.Scan(
			&i.ID,
			&i.NameEn,
			&i.Language,
			&i.Price,
			&i.ImageUrl,
			&i.Finish,
			&i.Rarity,
			&i.ManaValue,
			&i.Colors,
			&i.Types,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrice = `-- name: GetPrice :one
SELECT price
FROM cards_price
WHERE card_id = ?1 AND finish = ?2
`

type GetPriceParams struct {
	CardID string `json:"cardID"`
	Finish string `json:"finish"`
}

func (q *Queries) GetPrice(ctx context.Context, arg GetPriceParams) (float64, error) {
	row := q.queryRow(ctx, q.getPriceStmt, getPrice, arg.CardID, arg.Finish)
	var price float64
	err := row.Scan(&price)
	return price, err
}

const listAvailableCards = `-- name: ListAvailableCards :many
SELECT 
    id, name_en, set_code, language, finish, stock
FROM
    cards
WHERE name_en LIKE '%' || ?1 || '%'
`

type ListAvailableCardsRow struct {
	ID       string `json:"id"`
	NameEn   string `json:"name_en"`
	SetCode  string `json:"set_code"`
	Language string `json:"language"`
	Finish   string `json:"finish"`
	Stock    int64  `json:"stock"`
}

func (q *Queries) ListAvailableCards(ctx context.Context, name sql.NullString) ([]ListAvailableCardsRow, error) {
	rows, err := q.query(ctx, q.listAvailableCardsStmt, listAvailableCards, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAvailableCardsRow
	for rows.Next() {
		var i ListAvailableCardsRow
		if err := rows.Scan(
			&i.ID,
			&i.NameEn,
			&i.SetCode,
			&i.Language,
			&i.Finish,
			&i.Stock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUniqueAvailableCards = `-- name: ListUniqueAvailableCards :many
SELECT 
   DISTINCT name_en
FROM
    cards
WHERE name_en LIKE '%' || ?1 || '%'
`

func (q *Queries) ListUniqueAvailableCards(ctx context.Context, name sql.NullString) ([]string, error) {
	rows, err := q.query(ctx, q.listUniqueAvailableCardsStmt, listUniqueAvailableCards, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name_en string
		if err := rows.Scan(&name_en); err != nil {
			return nil, err
		}
		items = append(items, name_en)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCardStock = `-- name: UpdateCardStock :exec
UPDATE cards
SET stock = ?1
WHERE id = ?2 AND language = ?3 AND finish = ?4
`

type UpdateCardStockParams struct {
	Stock    int64  `json:"stock"`
	ID       string `json:"id"`
	Language string `json:"language"`
	Finish   string `json:"finish"`
}

func (q *Queries) UpdateCardStock(ctx context.Context, arg UpdateCardStockParams) error {
	_, err := q.exec(ctx, q.updateCardStockStmt, updateCardStock,
		arg.Stock,
		arg.ID,
		arg.Language,
		arg.Finish,
	)
	return err
}
